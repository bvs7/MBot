

class MPlayer:

    def __init__(self, id, role, name=None):
        self.id = id
        self.role = role
        self.name = name
        self.vote = None
        self.target = None
		
		self.timered = False
        
    def __str__(self):
        return "{}({})".format(self.name, self.id)
        

class MState:

    def __init__(self, id, mainComm, maifaComm, lobbyComm, rules, roles, rec):
        """Create a mafia game.
        
        id -- The unique string for this game
        mainComm, 
        mafiaComm, 
        lobbyComm -- The MComm objects for specific chats
        rules -- The rules dict which specifies chosen rules for game
        roles -- A player_id -> Role dictionary generated by MRoleGen
        rec --  The MRecord device used to log the game events
        """
        
        self.id = id
        self.mainComm = mainComm
        self.mafiaComm = mafiaComm
        self.lobbyComm = lobbyComm
        self.rules = rules # TODO let this be default (None)
        self.rec = rec
        
        # Generate initial state
        self.day = 0
        self.phase = "Init"
        self.players = []
        self.num_mafia = 0
        
        self.savedRoles = roles
        self.mafia_target = None
        self.blocked_ids = []
        
        self.timer = None
        
        self.null = MPlayer("0", None, None)
        
        
        # Initialize players
        for p_id, role in roles.items:
            name = self.lobbyComm.getName(p_id)
            self.players += MPlayer(p_id, role, name)
            if role in MAFIA_ROLES:
                self.num_mafia += 1
                
        self.players.sort(key=(lambda player:player.name))
        
        
        self.rec.create(self.id, self.players) # Log the creation of this game
        
    def startGame(self):
        
        # Add all players
        
        for player in self.players:
            self.mainComm.send("You are {}\n".format(player.role),player.id)
            self.mainComm.add(player.id, player.name)
            if player.role in MAFIA_ROLES:
                self.mafiaComm.add(player.id, None)
                
        self.day = 1
        self.phase = "Day"
        
        # Starting messages
        
        msg = START_GAME_MESSAGE_MAIN + "\nPlayers:"
        for p in self.players:
            msg += "\n " + player.name
            
        if "known_roles" in self.rules:
            if self.rules["known_roles"] == "ON":
                msg += "\nThe Roles:" + self.__showRoles()
            elif self.rules["known_roles"] == "TEAM":
                msg += "\nThe Teams:" + self.__showTeams()
                
        self.mainComm.cast(msg)
        
        msg = START_GAME_MESSAGE_MAFIA + "\nYour Team:\n"
        mafList = [p for p in self.players if p.role in MAFIA_ROLES].sort(lambda x:x.name)
        msg += "\n".join([p.name + ": " + p.role for p in mafList])
        
        self.mafiaComm.cast(msg)
        
        self.rec.start()
        
        if "start_night" in self.rules and (self.rules["start_night"] == "ON"
           or self.rules["start_night"] == "EVEN" and len(self.players%2==0)):
           self.__toNight()
           
           
    def vote(self, voter_id, votee_id):
        """Change voter's vote to votee then checks for decision."""
        if not self.phase == "Day":
            self.mainComm.cast("You can only vote during the Day")
            return
            
        try:
            voter = self.getPlayer(voter_id)
        except Exception as e: # TODO: replace with custom exception?
            self.mainComm.cast("Error processing vote: Bad voter id")
            return
            
        if votee_id == None:
            votee = None
        elif votee_id == "0":
            votee = self.null
        else:
            try:
                votee = self.getPlayer(votee_id)
            except Exception as e: # TODO: replace with custom exception?
                self.mainComm.cast("Error processing vote: Bad votee id")
                return
                
        voter.vote = votee
        
        self.rec.vote(voter, votee)
        
        self.__checkVotes(votee)
        
    def mafia_target(self, target_option):
        """ Change Mafia's target to players[target_option] """
        if not self.phase == "Night":
            self.mafiaComm.cast("You can only target during the night")
            return
        
        target_number = ord(target_option)-ord('A')
        if target_number == len(self.players):
            target = self.null
        elif target_number == None:
            target = None
        else:
            target = self.players[target_number]
            
        self.mafia_target = target
        self.mafiaComm.cast("It is done, targeted {}".format(target_option))
        
        self.rec.mafia_target(target)
        
    def mafia_options(self):
        """ Send the mafia's options to the mafia chat. """
        msg = "Use /target letter (i.e. /target B) to select someone to kill:"
        c = 'A'
        for player in self.players:
            msg += "\n"+c+" "+player.name
            c = chr(ord(c)+1)
        msg += "\n"+c+" No kill"
        self.mafiaComm.cast(msg)
		
	def target(self, p, target_option):
		""" Change p's target to players[target_option]. """
        try:
            player = self.getPlayer(p)
        except Exception as e:
            return
			
		if not self.time == "Night":
            self.mainComm.send("You can only target at Night",player.id)
            return

			
        target_number = ord(target_option)-ord('A')
        if target_number == len(self.players):
            target = self.null
        elif target_number == None:
            target = None
        else:
            target = self.players[target_number]
			
		if player.role == "MILKY" and target == player:
		    self.mainComm.send("Ewwww please don't milk yourself in front of me", player.id)
			return
		
        player.target = target
		self.mainComm.send("It is done, targeted {}".format(target_option),player.name)
		
		self.rec.target(player, target)

        self.__checkToDay()
		
	def send_options(self,prompt,p):
        """ Send list of options to player p with preface prompt. """
        try:
            send_player = self.getPlayer(p)
        except Exception as e:
			# TODO Error message/recovery?
			return
        msg = prompt
        c = 'A'
        for player in self.players:
            msg += "\n"+c+" "+player.name
            c = chr(ord(c)+1)
        msg += "\n"+c+" No target"
        self.mainComm.send(msg,send_player.id)
          
    def try_reveal(self, p):
		"""Attempt to reveal. If not a CELEB or it's night or CELEB was stripped, fail"""
        try:
            player = self.getPlayer(p)
        except Exception as e:
            # TODO Error logging
            return

        if player.role == "CELEB":
			if not self.time == "Day":
				self.mainComm.send("Must reveal during Day",player.id)
				return
            if player.id in self.blocked_ids:
                self.mainComm.send("You were distracted",player.id)
            else:
                self.rec.reveal(player)
                self.reveal(player.id)
		else:
			self.mainComm.send("Only CELEB can reveal themselves.",player.id)
			return

    def reveal(self,p):
        """ Reveal a player's role to the Main Chat """
        try:
            player = self.getPlayer(p)
        except Exception as e:
            # TODO Error Logging
            return
        self.mainComm.cast(player.name + " is " + player.role)
		
	def revealTeam(self,p):
        """ Reveal a player's team to the Main Chat """
        try:
            player = self.getPlayer(p)
        except Exception as e:
            # Error Logging
            return
        if player.role in MAFIA_ROLES:
            team = "Mafia"
        elif player.role in TOWN_ROLES:
            team = "Town"
        elif player.role in ROGUE_ROLES:
            team = "Rogue"
        self.mainComm.cast(player.name + " is aligned with " + team)
        return
            
    def getPlayer(self, p):
        """ p can be player or id, either way returns the player object associated. """
        
        if type(p) == Player:
            return p_id
        elif type(p) == str:
            players = [player for player in self.players if player.id == p]
            if len(players) >= 1:
                return players[0]
            else:
                raise Exception("Couldn't find player from id {}".format(p)) # TODO: make an appropriate exception
        else:
            raise Exception("Couldn't find player from {}".format(p))
			
	def setTimer(self, player_id):
        """ Start an N * 5 minute timer where N is number of players, or reduce timer by 5 minutes """
		try:
			player = self.getPlayer(p)
		except Exception as e:
			# Error logging
			return
		
		if player.timered:
			self.mainComm.cast("You have already timered.")
			return
			
		if self.timer == None:
			player.timered = true
			self.timer = 
			
		